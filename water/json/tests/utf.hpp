// Copyright 2017-2018 Johan Paulsson
// This file is part of the Water C++ Library. It is licensed under the MIT License.
// See the license.txt file in this distribution or https://watercpp.com/license.txt
//\_/\_/\_/\_/\_/\_/\_/\_/\_/\_/\_/\_/\_/\_/\_/\_/\_/\_/\_/\_/\_/\_/\_/\_/\_/\_/\_/\_
#ifndef WATER_JSON_TESTS_UTF_HPP
#define WATER_JSON_TESTS_UTF_HPP
#include <water/json/tests/bits.hpp>
#include <water/allocator.hpp>
#ifdef WATER_NO_CHEADERS
	#include <string.h>
#else
	#include <cstring>
	namespace water { using std::memcmp; }
#endif
namespace water { namespace json { namespace tests {

/*

test json::encoding + json::read with various utf encodings as raw memory or iterators

the correct string will be utf_plain_8 wihout the first and last quote

*/

char8_t constexpr utf_plain_8[]                = {0x22,0xf0,0x9f,0x90,0x89,0xf0,0x9f,0x90,0xb3,0x22};
char8_t constexpr utf_plain_8_bom[]            = {0xef,0xbb,0xbf,0x22,0xf0,0x9f,0x90,0x89,0xf0,0x9f,0x90,0xb3,0x22};
char8_t constexpr utf_plain_16_big_endian[]    = {0x00,0x22,0xd8,0x3d,0xdc,0x09,0xd8,0x3d,0xdc,0x33,0x00,0x22};
char8_t constexpr utf_plain_16_little_endian[] = {0x22,0x00,0x3d,0xd8,0x09,0xdc,0x3d,0xd8,0x33,0xdc,0x22,0x00};
char8_t constexpr utf_plain_16_bom[]           = {0xfe,0xff,0x00,0x22,0xd8,0x3d,0xdc,0x09,0xd8,0x3d,0xdc,0x33,0x00,0x22};
char8_t constexpr utf_plain_32_big_endian[]    = {0x00,0x00,0x00,0x22,0x00,0x01,0xf4,0x09,0x00,0x01,0xf4,0x33,0x00,0x00,0x00,0x22};
char8_t constexpr utf_plain_32_little_endian[] = {0x22,0x00,0x00,0x00,0x09,0xf4,0x01,0x00,0x33,0xf4,0x01,0x00,0x22,0x00,0x00,0x00};
char8_t constexpr utf_plain_32_bom[]           = {0x00,0x00,0xfe,0xff,0x00,0x00,0x00,0x22,0x00,0x01,0xf4,0x09,0x00,0x01,0xf4,0x33,0x00,0x00,0x00,0x22};

char8_t constexpr utf_escaped_8[]                = {0x22,0x5c,0x75,0x64,0x38,0x33,0x64,0x5c,0x75,0x64,0x63,0x30,0x39,0x5c,0x75,0x64,0x38,0x33,0x64,0x5c,0x75,0x64,0x63,0x33,0x33,0x22};
char8_t constexpr utf_escaped_8_bom[]            = {0xef,0xbb,0xbf,0x22,0x5c,0x75,0x64,0x38,0x33,0x64,0x5c,0x75,0x64,0x63,0x30,0x39,0x5c,0x75,0x64,0x38,0x33,0x64,0x5c,0x75,0x64,0x63,0x33,0x33,0x22};
char8_t constexpr utf_escaped_16_big_endian[]    = {0x00,0x22,0x00,0x5c,0x00,0x75,0x00,0x64,0x00,0x38,0x00,0x33,0x00,0x64,0x00,0x5c,0x00,0x75,0x00,0x64,0x00,0x63,0x00,0x30,0x00,0x39,0x00,0x5c,0x00,0x75,0x00,0x64,0x00,0x38,0x00,0x33,0x00,0x64,0x00,0x5c,0x00,0x75,0x00,0x64,0x00,0x63,0x00,0x33,0x00,0x33,0x00,0x22};
char8_t constexpr utf_escaped_16_little_endian[] = {0x22,0x00,0x5c,0x00,0x75,0x00,0x64,0x00,0x38,0x00,0x33,0x00,0x64,0x00,0x5c,0x00,0x75,0x00,0x64,0x00,0x63,0x00,0x30,0x00,0x39,0x00,0x5c,0x00,0x75,0x00,0x64,0x00,0x38,0x00,0x33,0x00,0x64,0x00,0x5c,0x00,0x75,0x00,0x64,0x00,0x63,0x00,0x33,0x00,0x33,0x00,0x22,0x00};
char8_t constexpr utf_escaped_16_bom[]           = {0xfe,0xff,0x00,0x22,0x00,0x5c,0x00,0x75,0x00,0x64,0x00,0x38,0x00,0x33,0x00,0x64,0x00,0x5c,0x00,0x75,0x00,0x64,0x00,0x63,0x00,0x30,0x00,0x39,0x00,0x5c,0x00,0x75,0x00,0x64,0x00,0x38,0x00,0x33,0x00,0x64,0x00,0x5c,0x00,0x75,0x00,0x64,0x00,0x63,0x00,0x33,0x00,0x33,0x00,0x22};
char8_t constexpr utf_escaped_32_big_endian[]    = {0x00,0x00,0x00,0x22,0x00,0x00,0x00,0x5c,0x00,0x00,0x00,0x75,0x00,0x00,0x00,0x64,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x33,0x00,0x00,0x00,0x64,0x00,0x00,0x00,0x5c,0x00,0x00,0x00,0x75,0x00,0x00,0x00,0x64,0x00,0x00,0x00,0x63,0x00,0x00,0x00,0x30,0x00,0x00,0x00,0x39,0x00,0x00,0x00,0x5c,0x00,0x00,0x00,0x75,0x00,0x00,0x00,0x64,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x33,0x00,0x00,0x00,0x64,0x00,0x00,0x00,0x5c,0x00,0x00,0x00,0x75,0x00,0x00,0x00,0x64,0x00,0x00,0x00,0x63,0x00,0x00,0x00,0x33,0x00,0x00,0x00,0x33,0x00,0x00,0x00,0x22};
char8_t constexpr utf_escaped_32_little_endian[] = {0x22,0x00,0x00,0x00,0x5c,0x00,0x00,0x00,0x75,0x00,0x00,0x00,0x64,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x33,0x00,0x00,0x00,0x64,0x00,0x00,0x00,0x5c,0x00,0x00,0x00,0x75,0x00,0x00,0x00,0x64,0x00,0x00,0x00,0x63,0x00,0x00,0x00,0x30,0x00,0x00,0x00,0x39,0x00,0x00,0x00,0x5c,0x00,0x00,0x00,0x75,0x00,0x00,0x00,0x64,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x33,0x00,0x00,0x00,0x64,0x00,0x00,0x00,0x5c,0x00,0x00,0x00,0x75,0x00,0x00,0x00,0x64,0x00,0x00,0x00,0x63,0x00,0x00,0x00,0x33,0x00,0x00,0x00,0x33,0x00,0x00,0x00,0x22,0x00,0x00,0x00};
char8_t constexpr utf_escaped_32_bom[]           = {0x00,0x00,0xfe,0xff,0x00,0x00,0x00,0x22,0x00,0x00,0x00,0x5c,0x00,0x00,0x00,0x75,0x00,0x00,0x00,0x64,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x33,0x00,0x00,0x00,0x64,0x00,0x00,0x00,0x5c,0x00,0x00,0x00,0x75,0x00,0x00,0x00,0x64,0x00,0x00,0x00,0x63,0x00,0x00,0x00,0x30,0x00,0x00,0x00,0x39,0x00,0x00,0x00,0x5c,0x00,0x00,0x00,0x75,0x00,0x00,0x00,0x64,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x33,0x00,0x00,0x00,0x64,0x00,0x00,0x00,0x5c,0x00,0x00,0x00,0x75,0x00,0x00,0x00,0x64,0x00,0x00,0x00,0x63,0x00,0x00,0x00,0x33,0x00,0x00,0x00,0x33,0x00,0x00,0x00,0x22};

struct utf_bytes {
	char8_t const *begin;
	size_t size;
	unsigned utf;
	int endian; // -1 0 1 little none big
	unsigned bom;
	};

utf_bytes constexpr utf_test_strings[] = {
	{utf_plain_8,                  sizeof(utf_plain_8)                 ,  8, 0, 0},
	{utf_plain_8_bom,              sizeof(utf_plain_8_bom)             ,  8, 0, 3},
	{utf_plain_16_big_endian,      sizeof(utf_plain_16_big_endian)     , 16, 1, 0},
	{utf_plain_16_little_endian,   sizeof(utf_plain_16_little_endian)  , 16,-1, 0},
	{utf_plain_16_bom,             sizeof(utf_plain_16_bom)            , 16, 1, 2},
	{utf_plain_32_big_endian,      sizeof(utf_plain_32_big_endian)     , 32, 1, 0},
	{utf_plain_32_little_endian,   sizeof(utf_plain_32_little_endian)  , 32,-1, 0},
	{utf_plain_32_bom,             sizeof(utf_plain_32_bom)            , 32, 1, 4},
	{utf_escaped_8,                sizeof(utf_escaped_8)               ,  8, 0, 0},
	{utf_escaped_8_bom,            sizeof(utf_escaped_8_bom)           ,  8, 0, 3},
	{utf_escaped_16_big_endian,    sizeof(utf_escaped_16_big_endian)   , 16, 1, 0},
	{utf_escaped_16_little_endian, sizeof(utf_escaped_16_little_endian), 16,-1, 0},
	{utf_escaped_16_bom,           sizeof(utf_escaped_16_bom)          , 16, 1, 2},
	{utf_escaped_32_big_endian,    sizeof(utf_escaped_32_big_endian)   , 32, 1, 0},
	{utf_escaped_32_little_endian, sizeof(utf_escaped_32_little_endian), 32,-1, 0},
	{utf_escaped_32_bom,           sizeof(utf_escaped_32_bom)          , 32, 1, 4}
	};
	
class utf_test {
	memory<> mymemory;
	public:
		void operator()(utf_bytes a) {
			mymemory.clear();
			void *p = mymemory.allocate(a.size, 1);
			memcpy(p, a.begin, a.size);
			auto e = encoding(p, a.size);
			___water_test(e);
			___water_test((a.utf == 8 && e.utf8()) || (a.utf == 16 && e.utf16()) || (a.utf == 32 && e.utf32()));
			___water_test(a.bom == e.byte_order_mark());
			if(a.endian == -1) ___water_test(e.little_endian());
			if(a.endian == 1) ___water_test(e.big_endian());
			if(a.endian == 0) ___water_test(!e.little_endian() && !e.big_endian());
			
			read<memory<>> r(mymemory);
			r.parse_in_place(p, a.size);
			___water_test(r);
			compare(r.nodes());
			}
		template<typename iterator_, typename size_or_iterator_>
		 void operator()(iterator_ begin, size_or_iterator_ size_or_end) {
			mymemory.clear();
			read<memory<>> r(mymemory);
			r(begin, size_or_end);
			___water_test(r);
			compare(r.nodes());
			}
		void compare(node<> a) {
			// do not call this verify because a macro on mac
			auto read = a.string();
			auto good = string<char8_t const*>(utf_plain_8 + 1, utf_plain_8 + sizeof(utf_plain_8) - 1);
			___water_test(read == good);
			}
	};

template<size_t size_>
 void utf_test_16(utf_test& test, char8_t const (&from)[size_]) {
	// from little endian!
	char16_t
		to[size_ / 2],
		*t = to,
		*te = to + size_ / 2;
	char8_t const *f = from;
	while(t != te) {
		*t++ =
			(static_cast<char16_t>(f[0]) << 0) |
			(static_cast<char16_t>(f[1]) << 8);
		f += 2;
		}
	test(static_cast<char16_t const*>(to), static_cast<char16_t const*>(to) + size_ / 2);
	test(static_cast<char16_t const*>(to), size_ / 2);
	};

template<size_t size_>
 void utf_test_32(utf_test& test, char8_t const (&from)[size_]) {
	// from little endian!
	char32_t
		to[size_ / 4],
		*t = to,
		*te = to + size_ / 4;
	char8_t const *f = from;
	while(t != te) {
		*t++ =
			(static_cast<char32_t>(f[0]) << 0) |
			(static_cast<char32_t>(f[1]) << 8) |
			(static_cast<char32_t>(f[2]) << 16) |
			(static_cast<char32_t>(f[3]) << 24);
		f += 4;
		}
	test(static_cast<char32_t const*>(to), static_cast<char32_t const*>(to) + size_ / 4);
	test(static_cast<char32_t const*>(to), size_ / 4);
	};

inline void utf() {
	utf_test test;
	for(auto a : utf_test_strings)
		test(a);
	test(utf_plain_8 + 0, utf_plain_8 + sizeof(utf_plain_8));
	test(utf_escaped_8 + 0, sizeof(utf_escaped_8));
	test(static_cast<char const*>(static_cast<void const*>(utf_plain_8)), sizeof(utf_plain_8));
	utf_test_16(test, utf_plain_16_little_endian);
	utf_test_16(test, utf_escaped_16_little_endian);
	utf_test_32(test, utf_plain_32_little_endian);
	utf_test_32(test, utf_escaped_32_little_endian);
	}

}}}
#endif
