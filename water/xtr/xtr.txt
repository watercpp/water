// xtr 2023
/////////////////////////////////////////////////////////////////////

√ goal 1:
trace << "hello"
should work and be 100% constexpr and threadsafe
trace is an empty struct with a forwarding operator<<
should be easy to make more like that

√ goal 2:
ministr::out<>{} is messy, make something easier to use
simplify cstring as much as possible?
cstring(ministr::no << ...)

√ goal 3:
simplify writing to a destination????
ministr::to(function) << ...

√ goal 4:
simplify writing operators??
simple enough as is?
(did easier write-to-function, xtr_operator_using_str)

√ no & to are good names?

class { operator expression(); }
works only if class is in same namespace as expression operators :(

template<typename a_>
auto operator<<(two& t, a_&& a) -> decltype(t.expression() << a) {
    return t.expression() << static_cast<a_&&>(a);
}
the object made inside that operator will be destroyed.
works only if t.expression() is a "start" expression that is not referenced via pointer/reference



// do
/////////////////////////////////////////////////////////////////////

√ example fold function?

√ documentation :(
  float digits is precision
  dont forget write(x, begin, end) is a normal way to write
  convince why to used xtr, and str
  char8

√ cleanup

√ year on all changed files

√ run tests on everything

√ remove visual c++ 2015 workarounds from str

√ out_insert_at_end (also str)
√ renaome insert_at_end
√ str rename out_something to_something

√ str::buffer + buffer_liens auto-select cstring function, like xtr

√ re-test unicode adjust end

√ tests for to + to_function + to_unbuffered and move-construct

√ test for to_begin_end (utf trucate is enough)

√ try WATER_XTR_SIZE_USED

√ to<unbuffered<something>> 

√ tests for basic things, remove stupid test.hpp

√ tests for types
  √ char
  √ string (char array, char pointer, range)
  √ int
  √ pointer
  √ float
  √ digits<123>
  √ base<16>
  √ no_exponent_min_max
  √ uppercase lowercase
  √ show_plus hide_plus
  √ show_base hide_base
  √ bytes

√ string<123> (no, char_array<123> is more efficient)

√ statisicts with buckets for size divided by 32 then in bucket 10 atomic counts for fullness percent

√ make sure char never skips zero (utf16/32 does?)

√ water::xtr_operator_using_str

√ move this file to xtr

√ reset ministr::attic

√ tests when string does not fit
√ especially utf8 cutting, when only 1 incomplete sequence is the string



// did
/////////////////////////////////////////////////////////////////////

√ track how much of the string is used with macro

√ check that empty expression never writes by itself
  this will write but does not matter: out << base<16>

√ str to array

√ strings should end on zero

√ hybrid!
√ buffer class will have functions to write one, begin+size, begin+end
√ buffer will proxy one-at-a-time
√ truncated works with unbuffered

√ utf8_cut is dumb, it starts from the beginning
√ change it and use it in write!!!

√ dont ever write from an empty expression

√ change write like this:
all write classes get the entire begin,end range that is left every time
they must write as many characters as possible (integer needs to write some digits)
the write function is responsible for cutting utf-8
when calling write(expression, begin, end) it might have written something beyond the returned end (utf-8 cut)

√ it does not make sense to cut parts of the expression, only cutting the end makes sense?

make sure all write will work if the destination is too small (should work now??)
must work even if too small:
end = write(expression, begin, end)
√ write string will adjust utf-8 ends, meaning sometimes there is space left even if string did not fit
√ write_int will not write any digits if they dont all fit
√ write_bytes will also not write anything if a byte does not fit
√ write_float writes everything it can excpet it uses write_int for exponent
√ write_utf_string is like write_string
√ write_utf_char is like write_string, it writes 1-4 chars

√ cstring should be called string? because it is not just a cstring
√ xtr::no << "lalala" << xtr::to_string is actually useful?

√ mylast = true (not mydo?)

√ function automatically works for function(char const*)??

√ remove out_begin_end

√ reduce string and extra size

√ size_t instead of unsigned

√ write_if will drop out << '\n'!!!!


// ministr 2016
/////////////////////////////////////////////////////////////////////

rvalue reference move always?
no, does not work if:
auto o = ministr::out<...>
o << "hello"

tabs!

can something be simplified??

can template bloat be reduced?
- moving code that does something to less tempalted code?
  write number / float could be done outside of the class
- rounding string size to 16 ???


// test
/////////////////////////////////////////////////////////////////////

compare example string to what it outputs?

that operators select the right

tests from old?

numeric_limits?

https://msdn.microsoft.com/en-us/library/ms173499.aspx
/bigobj
